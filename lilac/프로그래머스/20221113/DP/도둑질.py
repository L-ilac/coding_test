# money[0] 와 money[-1]이 계산식에 동시에 안들어갔다는 것을 어떻게 보장할 것인가? -> 이게 문제임
# 1 ~ n개의 집이 있다고하자, 1 ~ n-1 까지 묶고, 2 ~ n 까지 묶어서 각각 최댓값을 구한다.
# 1 ~ n-1 의 그룹일 경우, n이 도둑이 훔치려는 집 목록에 들어가지 않으려면, 목록에 1 과 n-1이 둘다 없어야한다.(인접한 집이므로)
# 즉 도둑이 계획한 집 목록에 1 or n-1(둘중 하나라도)이 포함되어 있다면, 자연스럽게 n은 배제되어야하고, 1 ~ n-1 로 묶은 그룹에서의 최대값이 곧 답.
# 근데 도둑이 계획한 집 목록에 1과 n-1이 없다면? (1 ~ n-1 그룹에서 계획을 짰는데, 집 목록에 1 과 n-1 둘다 없다면?)
# 그럼 사실상 도둑이 계획한 집 목록은 2 ~ n-2 들로만 이루어져있다. 이 경우에는 여기에 자유롭게 n을 넣을 수 있는데, 이는 곧 2 ~ n 로 묶은 그룹에서의 최대값과 동일하다.


def solution(money):
    pool1 = money[:-1]  # 1 ~ n-1 그룹
    pool2 = money[1:]  # 2 ~ n 그룹

    pool1[1] = max(pool1[0], pool1[1])
    pool2[1] = max(pool2[0], pool2[1])

    answer = 0

    for i in range(2, len(money)-1):
        pool1[i] = max(pool1[i-1], pool1[i-2]+pool1[i])
        pool2[i] = max(pool2[i-1], pool2[i-2]+pool2[i])

    answer = max(pool1[-1], pool2[-1])

    return answer
