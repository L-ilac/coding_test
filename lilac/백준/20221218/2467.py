# 산성용액 1 ~ 1,000,000,000  | 알칼리용액 -1 ~ -1,000,000,000

# 산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.

n = int(input())
solutions = list(map(int, input().split()))

left = 0
right = len(solutions)-1

# 접근법
# 1. 주어진 용액에서 양쪽 끝값을 더해서
# 2-1. 현재 구해진 용액이 +면, 오른쪽 인덱스를 줄인다. (-값에 비해 +값이 커서 더한 값이 +가 나오는 거니까.)
# 2-2. 현재 구해진 용액이 -면, 왼쪽 인덱스를 늘린다. (+값에 비해 -값이 커서 더한 값이 +가 나오는 거니까.)
# 3. 매번 인덱스를 조절해서 용액값을 구하고 이전 최솟값과 비교하여, 최솟값을 갱신한다. 최솟값을 갱신할 때마다, 해당 인덱스를 기억하기위해 저장한다.

min_index = (left, right)
min_mixed = 2000000000  # 두가지 용액을 섞었을때 나올 수 있는 최댓값

# left와 right가 같은 값에서 만나기전까지(mixed가 0이 나오면 끝내도 됌) 계속 탐색해야함.
# 그 이유는 0이 아닌 다른 값은 인덱스가 조절되면서 새롭게 갱신될 여지가 있기 떄문
# ex) -98 -3 2 96 -> -98 + 96 = -2는 충분히 0에 가깝지만, 그보다 더 안쪽에 -3 + 2 = -1 이라는 더 좋은 조합이 존재할 수 있기 떄문
while left < right:
    mixed = solutions[left] + solutions[right]

    if abs(mixed) <= min_mixed:  # 최솟값을 갱신하는 경우에만 해당 인덱스들을 갱신하면 됌.
        min_mixed = abs(mixed)
        min_index = (left, right)

    # 문제에서 답이 여러개면 아무거나 출력하라고 했음. 그러므로 모든 용액 조합을 다 찾아보기전에 용액값이 0인 조합이 나오면 그냥 바로 탈출
    if mixed == 0:
        break
    elif mixed > 0:
        right -= 1
    else:
        left += 1

print(solutions[min_index[0]], solutions[min_index[1]])
