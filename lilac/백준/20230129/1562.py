# 길이가 10인 0~9를 모두 포함하는 계단수는 9876543210 밖에 없음.
# 9 87 과 98 7 의 경우 각 사이에 넣는 케이스가 겹치는 경우가 있다
# 0과 9는 각 경계선이라 한가지 방향으로 밖에 못감

n = int(input())


# ! dp[i][j][k] i는 수의 길이, j는 맨 앞자리 숫자, k는 0~9(1111111111(2진수))가 사용되었는지를 나타내는 값
# ! j를 맨 앞자리라고 생각하던 맨 뒷자리라고 생각하던 어차피 결과적으로 맨 뒷자리가 0인 경우의 갯수 = 맨 앞자리가 0인 경우의 갯수임. 숫자의 길이가 늘어날 때, 숫자를 맨 앞에 붙이냐 맨 뒤에 붙이냐 그 차이.


dp = [[[0]*(1 << 10) for _ in range(10)] for _ in range(n+1)]


for j in range(10):
    dp[1][j][1 << j] = 1

for i in range(2, n+1):
    for j in range(10):
        for k in range(1 << 10):
            if j == 9:
                dp[i][j][(1 << j) | k] += dp[i-1][j-1][k]
            elif j == 0:
                dp[i][j][(1 << j) | k] += dp[i-1][j+1][k]
            else:
                dp[i][j][(1 << j) | k] += dp[i-1][j-1][k]
                dp[i][j][(1 << j) | k] += dp[i-1][j+1][k]

            dp[i][j][(1 << j) | k] %= 1000000000


answer = 0
for j in range(1, 10):
    answer += dp[n][j][(1 << 10)-1]
    answer %= 1000000000

print(answer)
